<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>C42 Flight Buddy</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: auto;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    input, button {
      padding: 10px;
      margin: 5px 0;
      width: 100%;
      font-size: 1rem;
    }
    #results {
      margin-top: 20px;
      padding: 15px;
      background: #fff;
      border-radius: 5px;
      white-space: pre-wrap;
    }
    .ok { color: green; }
    .bad { color: red; }
    .warn { color: orange; }
    .highlight-text {
      font-weight: normal !important;
    }
    canvas {
      margin-top: 20px;
      background: #fff;
      border-radius: 5px;
      max-width: 100%;
    }
  </style>
</head>
<body>
  <h1>C42 Flight Buddy</h1>
  <p><em>Version: 15</em></p>
  <p>Check flight weather from Swansea Airport</p>

  <label for="start">Flight start (GMT):</label>
  <input type="datetime-local" id="start" />

  <label for="duration">Flight duration (hours):</label>
  <input type="number" id="duration" min="0.5" step="0.5" value="1" />

  <button onclick="checkFlight()">Check Flight</button>

  <div id="results"></div>
  <canvas id="windChart" style="display:none;"></canvas>

<script>
const LAT = 51.605;
const LON = -4.064;
const API_KEY = '81a0d8bef1288c6437560f89b336dd33';
const elevation = 295; // meters

function estimateDewPoint(temp, humidity) {
  return temp - ((100 - humidity) / 5);
}

function estimateCloudBase(temp, dewPoint) {
  return Math.round((temp - dewPoint) * 400); // in feet AGL
}

function formatUKDate(date) {
  const d = date.getUTCDate().toString().padStart(2, '0');
  const m = (date.getUTCMonth() + 1).toString().padStart(2, '0');
  const y = date.getUTCFullYear();
  const h = date.getUTCHours().toString().padStart(2, '0');
  const min = date.getUTCMinutes().toString().padStart(2, '0');
  return `${d}/${m}/${y}, ${h}:${min} GMT`;
}

function formatInputDateTimeLocal(date) {
  // Format for input[type=datetime-local]: "YYYY-MM-DDTHH:MM"
  const y = date.getFullYear();
  const m = (date.getMonth() + 1).toString().padStart(2, '0');
  const d = date.getDate().toString().padStart(2, '0');
  const h = date.getHours().toString().padStart(2, '0');
  const min = date.getMinutes().toString().padStart(2, '0');
  return `${y}-${m}-${d}T${h}:${min}`;
}

function getIcingRisk(temp, humidity, cloudCover, weatherDesc) {
  if (temp > 4) return { risk: "Low", color: "normal" };
  // Moisture + temp near freezing + significant clouds/rain increases risk
  if (
    temp <= 4 &&
    humidity >= 85 &&
    cloudCover > 50 &&
    (weatherDesc.toLowerCase().includes("rain") ||
      weatherDesc.toLowerCase().includes("snow") ||
      weatherDesc.toLowerCase().includes("freezing"))
  ) return { risk: "Risk", color: "red" };
  return { risk: "Low", color: "normal" };
}

function getRainWarning(cloudCover, weatherDesc) {
  if (!weatherDesc.toLowerCase().includes("rain")) return { text: null, color: "normal" };
  if (weatherDesc.toLowerCase().includes("light rain") && cloudCover <= 50) {
    return { text: "Light rain with low cloud — use caution", color: "orange" };
  } else {
    return { text: "Rain with significant cloud cover — not suitable", color: "red" };
  }
}

function checkLimits(wind, gust, vis, desc, cloudCover, cloudBase) {
  if (gust > 20) return { safe: false, msg: "Gust exceeds C42 limits (>20 kt)" };
  if (wind > 20) return { safe: false, msg: "Wind exceeds C42 limits (>20 kt)" };
  if (vis < 5000) return { safe: false, msg: "Visibility too low (<5000 m)" };
  if (desc.toLowerCase().includes("fog") || desc.toLowerCase().includes("mist")) {
    return { safe: false, msg: "Fog or mist present — not suitable" };
  }
  if (cloudBase < 1000) return { safe: false, msg: "Estimated cloud base below 1000 ft AGL" };
  return { safe: true, msg: "" };
}

function predictRunway(windDir) {
  const runways = { '04': 40, '22': 220, '10': 100, '28': 280 };
  return Object.entries(runways).reduce((a, b) => {
    const aDiff = Math.min(Math.abs(a[1] - windDir), 360 - Math.abs(a[1] - windDir));
    const bDiff = Math.min(Math.abs(b[1] - windDir), 360 - Math.abs(b[1] - windDir));
    return aDiff < bDiff ? a : b;
  })[0];
}

// Simple turbulence estimate (random for demo) below 5000 ft - replace with real logic or data if available
function estimateTurbulence() {
  const levels = ["None", "Light", "Moderate"];
  return levels[Math.floor(Math.random() * levels.length)];
}

// Wind shear prediction (simple heuristic)
function predictWindShear(windSpeed, windGust, windDir, runwayDir) {
  // If gust is significantly higher than wind speed and wind direction is across runway, possible wind shear
  const diffGust = windGust - windSpeed;
  const runwayAngle = runwayDir;
  const windAngle = windDir;
  const angleDiff = Math.min(Math.abs(runwayAngle - windAngle), 360 - Math.abs(runwayAngle - windAngle));
  // Wind shear if gusts >5 kt higher and angleDiff between 60-120 (crosswind)
  if (diffGust > 5 && angleDiff >= 60 && angleDiff <= 120) {
    return true;
  }
  return false;
}

let windChartInstance = null;

async function checkFlight() {
  const startInput = document.getElementById("start").value;
  const duration = parseFloat(document.getElementById("duration").value);
  const resDiv = document.getElementById("results");
  const windChartCanvas = document.getElementById("windChart");

  if (!startInput || isNaN(duration) || duration <= 0) {
    resDiv.innerHTML = '<p class="bad">Please enter a valid start time and duration.</p>';
    windChartCanvas.style.display = "none";
    return;
  }

  const startTime = new Date(startInput + "Z"); // GMT
  const now = new Date();
  const maxForecastTime = new Date(now.getTime() + 5 * 24 * 60 * 60 * 1000);
  const endTime = new Date(startTime.getTime() + duration * 3600 * 1000);

  if (startTime <= now || startTime > maxForecastTime || endTime > maxForecastTime) {
    resDiv.innerHTML = '<p class="bad">Please enter a valid start time and duration within the next 5 days.</p>';
    windChartCanvas.style.display = "none";
    return;
  }

  resDiv.innerHTML = '<p>Loading weather data...</p>';
  windChartCanvas.style.display = "none";

  try {
    const response = await fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${LAT}&lon=${LON}&appid=${API_KEY}&units=metric`);
    const data = await response.json();

    // Find forecast closest to startTime or just before
    let previousInterval = null;
    for (let i = data.list.length - 1; i >= 0; i--) {
      const forecastStart = new Date(data.list[i].dt * 1000);
      if (forecastStart <= startTime) {
        previousInterval = data.list[i];
        break;
      }
    }
    if (!previousInterval) {
      for (let item of data.list) {
        const forecastStart = new Date(item.dt * 1000);
        if (forecastStart > startTime) {
          previousInterval = item;
          break;
        }
      }
    }

    if (!previousInterval) {
      resDiv.innerHTML = '<p class="bad">No forecast data available for selected flight window.</p>';
      return;
    }

    let relevantForecasts = [previousInterval];
    data.list.forEach(item => {
      const forecastStart = new Date(item.dt * 1000);
      if (forecastStart > previousInterval.dt * 1000 && forecastStart < endTime) {
        relevantForecasts.push(item);
      }
    });

    if (relevantForecasts.length === 0) {
      resDiv.innerHTML = '<p class="bad">No forecast data available for selected flight window.</p>';
      return;
    }

    let messages = [];
    let issues = [];

    relevantForecasts.forEach(item => {
      const main = item.main || {};
      const wind = item.wind || {};
      const weatherArr = item.weather || [];
      const clouds = item.clouds || {};
      const pressure = main.pressure || 0;
      const humidity = main.humidity || 0;
      const temp = main.temp || 0;
      const windDeg = wind.deg || 0;
      const windSpeed = wind.speed || 0;
      const windGust = wind.gust || 0;
      const visibilityRaw = item.visibility !== undefined ? item.visibility : 10000;
      const visibility = visibilityRaw > 5000 ? ">5000 m" : `${visibilityRaw} m`;
      const cloudCover = clouds.all || 0;
      const weatherDesc = weatherArr.length ? weatherArr[0].description : "unknown";

      const dewPoint = estimateDewPoint(temp, humidity);
      const cloudBase = estimateCloudBase(temp, dewPoint);
      const windKts = (windSpeed * 1.94384);
      const windGustKts = (windGust * 1.94384);
      const QFE = (pressure - (elevation * 0.12)).toFixed(1);
      const runway = predictRunway(windDeg);
      const safe = checkLimits(windKts, windGustKts, visibilityRaw, weatherDesc, cloudCover, cloudBase);
      const icing = getIcingRisk(temp, humidity, cloudCover, weatherDesc);
      const rainWarn = getRainWarning(cloudCover, weatherDesc);
      const turbulence = estimateTurbulence();
      const windShear = predictWindShear(windKts, windGustKts, windDeg, parseInt(runway) * 10);

      const timeLabel = formatUKDate(new Date(item.dt * 1000));

      // Helper to wrap warning text in spans with color class for partial highlight
      function colorText(label, value, color) {
        if (color === "red") return `${label}: <span class="bad">${value}</span>`;
        if (color === "orange") return `${label}: <span class="warn">${value}</span>`;
        return `${label}: ${value}`;
      }

      messages.push(
`${colorText("Time", timeLabel, "normal")}
Temperature: ${temp.toFixed(1)}°C
${safe.safe || cloudBase >= 1000 ? `Cloud base: ~${cloudBase} ft AGL` : `Cloud base: <span class="bad">~${cloudBase} ft AGL</span>`}
QNH: ${pressure} hPa
QFE: ${QFE} hPa
Wind: ${windDeg}° @ ${windKts.toFixed(1)} kt
${windGustKts > 0 ? (windGustKts > 20 ? `Gusts: <span class="bad">${windGustKts.toFixed(1)} kt</span>` : `Gusts: ${windGustKts.toFixed(1)} kt`) : ''}
${colorText("Visibility", visibility, visibilityRaw < 5000 ? "red" : "normal")}
Cloud cover: ${cloudCover} %
${colorText("Weather", weatherDesc, rainWarn.color)}
Icing Risk: ${icing.color === "red" ? `<span class="bad">${icing.risk}</span>` : icing.risk}
Turbulence below 5000ft: ${turbulence}
Wind shear on runway ${runway}: ${windShear ? '<span class="bad">Possible</span>' : 'No'}
Predicted Runway: ${runway}
Status: ${safe.safe ? "✅ OK" : "❌ Limit Exceeded"}`
      );

      if (!safe.safe) {
        issues.push(`At ${timeLabel}: ${safe.msg}`);
      }
      if (icing.color === "red") {
        issues.push(`At ${timeLabel}: Icing risk detected`);
      }
      if (rainWarn.color === "red") {
        issues.push(`At ${timeLabel}: ${rainWarn.text}`);
      }
      if (windShear) {
        issues.push(`At ${timeLabel}: Possible wind shear on runway ${runway}`);
      }
    });

    const overallStatus = issues.length === 0
      ? '<p class="ok"><strong>✅ Weather suitable for full flight duration.</strong></p>'
      : `<p class="bad"><strong>❌ Weather issues detected during flight.</strong></p>`;

    resDiv.innerHTML = `
      <h3>Flight Weather Check for ${formatUKDate(startTime)} to ${formatUKDate(endTime)}</h3>
      <pre>${messages.join("\n\n")}</pre>
      ${overallStatus}
    `;

    // Conditional wind chart display only if duration > 1 hour
    if (duration > 1) {
      windChartCanvas.style.display = "block";
      renderWindChart(relevantForecasts);
    } else {
      windChartCanvas.style.display = "none";
      if (windChartInstance) {
        windChartInstance.destroy();
        windChartInstance = null;
      }
    }
  } catch (error) {
    resDiv.innerHTML = '<p class="bad">Failed to load weather data. Try again later.</p>';
    windChartCanvas.style.display = "none";
  }
}

function renderWindChart(forecasts) {
  const ctx = document.getElementById('windChart').getContext('2d');
  const labels = forecasts.map(item => {
    const d = new Date(item.dt * 1000);
    return `${d.getUTCHours()}:00`;
  });
  const windSpeeds = forecasts.map(item => (item.wind.speed * 1.94384).toFixed(1));
  const gustSpeeds = forecasts.map(item => item.wind.gust ? (item.wind.gust * 1.94384).toFixed(1) : null);

  if (windChartInstance) windChartInstance.destroy();

  windChartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label: 'Wind Speed (kt)',
          data: windSpeeds,
          borderColor: 'blue',
          fill: false,
        },
        {
          label: 'Gust Speed (kt)',
          data: gustSpeeds,
          borderColor: 'red',
          fill: false,
        }
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: {
          display: true,
        },
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Speed (kt)'
          }
        },
        x: {
          title: {
            display: true,
            text: 'Time (GMT)'
          }
        }
      }
    }
  });
}

window.onload = () => {
  const now = new Date();
  now.setMinutes(0, 0, 0);
  now.setHours(now.getHours() + 1); // Next hour for future start time
  document.getElementById('start').value = formatInputDateTimeLocal(now);
  document.getElementById('duration').value = "1";
  checkFlight();
};

// Load Chart.js from CDN
(function loadChartJs() {
  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
  script.onload = () => {};
  document.head.appendChild(script);
})();
</script>
</body>
</html>
