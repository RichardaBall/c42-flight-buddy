<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>C42 Flight Buddy</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: auto;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    input, button {
      padding: 10px;
      margin: 5px 0;
      width: 100%;
      font-size: 1rem;
    }
    #results {
      margin-top: 20px;
      padding: 15px;
      background: #fff;
      border-radius: 5px;
      white-space: pre-wrap;
      font-weight: normal;
    }
    .ok { color: green; }
    .bad { color: red; }
    .warn { color: orange; }
    .highlight {
      font-weight: normal;
    }
  </style>
</head>
<body>
  <h1>C42 Flight Buddy</h1>
  <p><em>Version: 21</em></p>
  <p>Check flight weather from Swansea Airport</p>

  <label for="start">Flight start (GMT):</label>
  <input type="datetime-local" id="start" />

  <label for="duration">Flight duration (hours):</label>
  <input type="number" id="duration" min="0.5" step="0.5" value="1" />

  <div id="results"></div>

<script>
const LAT = 51.60238324222334;
const LON = -4.069685406781575;
const API_KEY = '81a0d8bef1288c6437560f89b336dd33';
const elevation = 295; // meters

// Sunrise and Sunset times lookup (GMT) for Swansea Airport
// Format: "YYYY-MM-DD": {sunrise: "HH:mm", sunset: "HH:mm"}
const sunTimes = {
  "2025-07-03": { sunrise: "04:03", sunset: "20:36" },
  "2025-07-04": { sunrise: "04:05", sunset: "20:35" },
  "2025-07-05": { sunrise: "04:06", sunset: "20:35" }
};

function parseTimeToDate(dateStr, timeStr) {
  // dateStr = "YYYY-MM-DD"
  // timeStr = "HH:mm"
  const [year, month, day] = dateStr.split("-").map(Number);
  const [hour, minute] = timeStr.split(":").map(Number);
  return new Date(Date.UTC(year, month -1, day, hour, minute));
}

function estimateDewPoint(temp, humidity) {
  return temp - ((100 - humidity) / 5);
}

function estimateCloudBase(temp, dewPoint) {
  return Math.round((temp - dewPoint) * 400); // in feet AGL
}

function highlight(label, value, condition, cls="bad") {
  if (!condition) return label + value;
  return `${label}<span class="${cls} highlight">${value}</span>`;
}

function predictRunway(windDir) {
  const runways = { '04': 40, '22': 220, '10': 100, '28': 280 };
  return Object.entries(runways).reduce((a, b) => {
    const aDiff = Math.min(Math.abs(a[1] - windDir), 360 - Math.abs(a[1] - windDir));
    const bDiff = Math.min(Math.abs(b[1] - windDir), 360 - Math.abs(b[1] - windDir));
    return aDiff < bDiff ? a : b;
  })[0];
}

function checkLimits(wind, gusts, vis, desc, cloudCover, cloudBase) {
  if (parseFloat(wind) > 20) return { safe: false, msg: "Wind exceeds C42 limits (>20 kt)" };
  if (parseFloat(gusts) > 20) return { safe: false, msg: "Gust exceeds C42 limits (>20 kt)" };
  if (vis < 3000) return { safe: false, msg: "Visibility too low (<3000 m)" };
  const descLower = desc.toLowerCase();
  if (descLower.includes("fog") || descLower.includes("mist")) {
    return { safe: false, msg: "Fog or mist present — not suitable" };
  }
  if (cloudBase < 1000) return { safe: false, msg: "Estimated cloud base below 1000 ft AGL" };
  return { safe: true, msg: "" };
}

function icingRisk(temp, dewPoint) {
  // More precise icing risk (example logic)
  if (temp <= 0 && temp >= -15 && Math.abs(temp - dewPoint) < 3) return "Risk";
  if (temp > 0 && temp <= 5 && Math.abs(temp - dewPoint) < 2) return "Risk";
  return "Low";
}

function getTurbulenceRisk(gusts) {
  // None, Low, Moderate, High based on gust speed (kt)
  if (gusts < 5) return "None";
  if (gusts < 12) return "Low";
  if (gusts < 20) return "Moderate";
  return "High";
}

function getWindShearRisk(windSpeed, gusts) {
  // Simple heuristic, adjust as needed
  const diff = gusts - windSpeed;
  if (diff < 5) return "None";
  if (diff < 10) return "Low";
  if (diff < 15) return "Moderate";
  return "High";
}

function colorForRisk(risk) {
  switch (risk) {
    case "None": return "";        // normal text
    case "Low": return "ok";       // green
    case "Moderate": return "warn"; // amber
    case "High": return "bad";     // red
    default: return "";
  }
}

function formatUKDate(d) {
  const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return `${days[d.getUTCDay()]}, ${String(d.getUTCDate()).padStart(2,'0')} ${months[d.getUTCMonth()]} ${d.getUTCFullYear()}, ${String(d.getUTCHours()).padStart(2,'0')}:${String(d.getUTCMinutes()).padStart(2,'0')} GMT`;
}

function checkFlight() {
  const startInput = document.getElementById("start").value;
  const duration = parseFloat(document.getElementById("duration").value);
  const resDiv = document.getElementById("results");

  if (!startInput || isNaN(duration) || duration <= 0) {
    resDiv.innerHTML = '<p class="bad">Please enter a valid start time and duration.</p>';
    return;
  }

  const startTime = new Date(startInput + "Z"); // GMT
  const now = new Date();
  const maxForecastTime = new Date(now.getTime() + 5 * 24 * 60 * 60 * 1000);
  const endTime = new Date(startTime.getTime() + duration * 3600 * 1000);

  if (startTime <= now || startTime > maxForecastTime || endTime > maxForecastTime) {
    resDiv.innerHTML = '<p class="bad">Please enter a valid start time and duration within the next 5 days.</p>';
    return;
  }

  resDiv.innerHTML = '<p>Loading weather data...</p>';

  fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${LAT}&lon=${LON}&appid=${API_KEY}&units=metric`)
    .then(res => res.json())
    .then(data => {
      // Find the forecast interval for start time (or just after)
      let startForecast = null;
      for (let i = 0; i < data.list.length; i++) {
        const fdt = new Date(data.list[i].dt * 1000);
        if (fdt >= startTime) {
          startForecast = data.list[i];
          break;
        }
      }
      if (!startForecast) {
        startForecast = data.list[data.list.length -1];
      }

      // Gather all relevant forecasts within flight time window
      const relevantForecasts = data.list.filter(item => {
        const fdt = new Date(item.dt * 1000);
        return fdt >= startTime && fdt <= endTime;
      });
      if (relevantForecasts.length === 0) relevantForecasts.push(startForecast);

      // Get flight day string (for sunTimes lookup)
      const flightDateStr = startTime.toISOString().slice(0,10);
      const sunInfo = sunTimes[flightDateStr];

      let sunriseDate = null;
      let sunsetDate = null;
      if (sunInfo) {
        sunriseDate = parseTimeToDate(flightDateStr, sunInfo.sunrise);
        sunsetDate = parseTimeToDate(flightDateStr, sunInfo.sunset);
      }

      // Check if flight inside daylight period
      let nightFlag = false;
      if (sunriseDate && sunsetDate) {
        if (startTime < sunriseDate || endTime > sunsetDate) {
          nightFlag = true;
        }
      } else {
        // Unknown sunrise/sunset times
        nightFlag = null;
      }

      const messages = relevantForecasts.map(item => {
        const main = item.main || {};
        const wind = item.wind || {};
        const weatherArr = item.weather || [];
        const clouds = item.clouds || {};
        const pressure = main.pressure || 0;
        const humidity = main.humidity || 0;
        const temp = main.temp || 0;
        const windDeg = wind.deg || 0;
        const windSpeed = wind.speed || 0;
        const gustSpeed = wind.gust || 0;
        const visibility = item.visibility !== undefined ? item.visibility : 10000;
        const cloudCover = clouds.all || 0;
        const weatherDesc = weatherArr.length ? weatherArr[0].description : "unknown";

        const dewPoint = estimateDewPoint(temp, humidity);
        const cloudBase = estimateCloudBase(temp, dewPoint);
        const windKts = (windSpeed * 1.94384);
        const gustKts = (gustSpeed * 1.94384);
        const QFE = (pressure - (elevation * 0.12)).toFixed(1);
        const runway = predictRunway(windDeg);
        const safe = checkLimits(windKts, gustKts, visibility, weatherDesc, cloudCover, cloudBase);
        const icing = icingRisk(temp, dewPoint);

        // Turbulence and Wind Shear Risk
        const turbulenceRisk = getTurbulenceRisk(gustKts);
        const turbulenceClass = colorForRisk(turbulenceRisk);
        const windShearRisk = getWindShearRisk(windKts, gustKts);
        const windShearClass = colorForRisk(windShearRisk);

        // Visibility color
        let visibilityClass = "";
        if (visibility < 3000) visibilityClass = "bad";
        else if (visibility < 5000) visibilityClass = "warn";

        // Format visibility
        const visDisplay = visibility > 5000 ? ">5000 m" : visibility + " m";

        // Format rain level color
        const rainLevel = (() => {
          const descLower = weatherDesc.toLowerCase();
          if (!descLower.includes('rain')) return 'none';
          if (descLower.includes('light') && cloudCover < 99) return 'warn';
          return 'bad';
        })();
        const rainClass = rainLevel === 'bad' ? 'bad' : rainLevel === 'warn' ? 'warn' : '';

        const timeLabel = formatUKDate(new Date(item.dt * 1000));

        return (
`${"Time: " + timeLabel}
Temperature: ${temp.toFixed(1)}°C
${highlight("Cloud base: ~", cloudBase + " ft AGL", cloudBase < 1000, "bad")}
QNH: ${pressure} hPa
QFE: ${QFE} hPa
${highlight("Wind: ", windDeg + "° @ " + windKts.toFixed(1) + " kt", windKts > 20, "bad")}
${highlight("Gusts: ", gustKts.toFixed(1) + " kt", gustKts > 20, "bad")}
${highlight("Visibility: ", visDisplay, visibility < 5000, visibilityClass)}
Cloud cover: ${cloudCover} %
Weather: <span class="${rainClass} highlight">${weatherDesc}</span>
Icing risk: ${icing === "Risk" ? `<span class="bad highlight">${icing}</span>` : icing}
Turbulence risk: <span class="${turbulenceClass} highlight">${turbulenceRisk}</span>
Wind shear risk: <span class="${windShearClass} highlight">${windShearRisk}</span>
Recommended runway: ${runway}
${safe.safe ? '<span class="ok highlight">All limits OK</span>' : `<span class="bad highlight">${safe.msg}</span>`}`
        );
      }).join("\n\n");

      let nightMessage = "";
      if (nightFlag === true) {
        nightMessage = `\n\n❌ Part of this flight is during night (sunrise: ${sunriseDate.toUTCString()}, sunset: ${sunsetDate.toUTCString()}). Daylight only operations permitted.`;
      } else if (nightFlag === false) {
        nightMessage = `\n\n✅ Flight is within daylight hours (sunrise: ${sunriseDate.toUTCString()}, sunset: ${sunsetDate.toUTCString()}).`;
      } else {
        nightMessage = `\n\n⚠️ Could not determine sunrise/sunset times.`;
      }

      resDiv.innerHTML =
        `Flight Weather Check for ${formatUKDate(startTime)} to ${formatUKDate(endTime)}\n\n` +
        messages +
        nightMessage;
    })
    .catch(e => {
      resDiv.innerHTML = `<p class="bad">Failed to load weather data: ${e.message}</p>`;
    });
}

// Auto update on input changes
document.getElementById("start").addEventListener("change", checkFlight);
document.getElementById("duration").addEventListener("input", checkFlight);

// Set default start time to now +1 hour rounded to nearest 30 min
function setDefaultStartTime() {
  const now = new Date();
  now.setUTCMinutes(now.getUTCMinutes() + 60);
  now.setUTCMinutes(now.getUTCMinutes() - (now.getUTCMinutes() % 30));
  const isoStr = now.toISOString().slice(0,16);
  document.getElementById("start").value = isoStr;
}
setDefaultStartTime();
checkFlight();

</script>
</body>
</html>
